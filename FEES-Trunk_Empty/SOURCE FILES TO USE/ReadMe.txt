NWC = Not Working Code
SU = State Unknown ( I don't remember / don't care)
WC = Working Code ( It compiles and it was ok for its purpose)


--------  FEES-Project ---------

0_FEES-EarlyIdeas --> ( just Ideas - Not working code )
These files are just our first tentative to understand what and how much data the whole system would require (to calculate the transmission data-rate)
also, how to structure the firmware ecc ecc.

1_ FEES-TestSuite_withMenu ( Proto-Project with Miosix-OS) - State Unknown - discontinued
This is a first working version of the firmware that was used mainly for hardware debugging in the early days. (Nov2017 I think).

2_FEES-ThermovoidTest-ChibiOS ( Final Test Version - Working Device Drivers) - Working Code
This was delivered in October 2018, as requested with urgence by the company for passing that specific test, it had 80% of the Device Drivers working.
It basically sampled continuously and shoot all the data through the Uart port. (very low side programming)
drivers are in the os/ex (external) folder


3_FEES-ApplicationLayer-master ( First Version) - WC
This is what I presented to the professor, this completed the work on the High side programming , what was really required of me for the thesis, in the beginning.
you can find the finitestatemachine.exe inside the Debug folder or here in (Other - FEES Documents)


4_FEES-ApplicationLayer-Layered Structure - WC  my tentative to the modular approach
I already tried to make it modular and restructure the 3rd repository to a layered structure and it also works.

5_FESS-CubeIDE-FreeRtos - Work in progress ( GPIOS,BUSSES,PWMS working ) (Device Drivers & FSM to be added)
This is the repository I was (and still am) working on.
The skeleton of this code has been generated by CubeMX - I made using this program all the MCU-Pinout and defined all the busses and periferals like timers and PWMs, then generate the code, and added several functions to test if the Hardware set-up i created ( the led and logic analizer arrangement) worked and it does.
I made several very simple tests for busses and GPIOS and tested all. It works.
Now it's just a matter to put all things together and deliever this project, 
It is ok to emulate sensors and deliever this with low functions as STUBS , as long as we can demostrate that funcions are called, we are ok, 
I suggest to use one serial bus (like the second - Fees_print() ) to track all functions called, and create a log from there.
So every function ideally has to have a Fees_print() inside where we say which function has been called, and in the transition of STATE we should highlight that also.


6_SingleFileProgram
This was my tentative to group all .h and .c s to just two files, so that all the high level could be included to the 5th repository code, but i don't know if it's a good idea, that's why I'm asking for help, never done a project so big.



9 _ArduNaut-master - ( Extra , for curiosity )-WC
Here is THE GIANT THING.
I did a porting , defining the port mapping and a basic behaviour in ARDU-Pilot and called Ardu-Naut.
You can see in the following video, me using the satellite and the Mav-link protocol to send telemetry in real time and calculating an estimate of its orientation in space. (kahlman filter) 
Enjoy.

Mavlink & ArduNaut
https://www.youtube.com/watch?v=Rqg18wKNKbk
https://www.youtube.com/watch?v=ld_cnOKcvF0
https://www.youtube.com/watch?v=59NvVJ87PVA
https://www.youtube.com/watch?v=-CN78ZRbKn4

Animations
https://www.youtube.com/watch?v=LyCcMgibuKU
https://www.youtube.com/watch?v=rF_xnyKtIjg
https://www.youtube.com/watch?v=Q3sDRpskP0E
https://www.youtube.com/watch?v=fQPVXzCV580
https://www.youtube.com/watch?v=ehmlhMgEzdw



Other - FEES Documents